

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Submodules &#8212; gdas 0.3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="_static/cloud.base.js"></script>
    <script type="text/javascript" src="_static/cloud.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Description of the code" href="excess_power.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body role="document">
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="excess_power.html" title="Description of the code"
             accesskey="P">previous</a> &nbsp; &nbsp;</li>
    <li><a href="index.html">gdas 0.3.0 documentation</a> &#187;</li>
 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="submodules">
<h1>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h1>
<div class="section" id="file-to-segment">
<span id="id1"></span><h2>file_to_segment<a class="headerlink" href="#file-to-segment" title="Permalink to this headline">¶</a></h2>
<p>The starting and ending UTC times for a specific HDF5 file are determined by using the =Date=, =t0= and =t1= attributes from the metadata. The [[construct_utc_from_metadata][=construct_utc_from_metadata=]] function is then used to calculate the UTC time. Finally, the [[<a class="reference external" href="http://software.ligo.org/docs/glue/glue.__segments.segment-class.html][=segment=">http://software.ligo.org/docs/glue/glue.__segments.segment-class.html][=segment=</a>]] module from the =glue.segments= library is used to represent the range of times in a semi-open interval.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">file_to_segment</span><span class="p">(</span><span class="n">hfile</span><span class="p">,</span><span class="n">segname</span><span class="p">):</span>
    <span class="c1"># Extract all atributes from the data</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="n">hfile</span><span class="p">[</span><span class="n">segname</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span>
    <span class="c1"># Define each attribute</span>
    <span class="n">dstr</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Date&quot;</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;t0&quot;</span><span class="p">],</span> <span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;t1&quot;</span><span class="p">]</span>
    <span class="c1"># Construct GPS starting time from data</span>
    <span class="n">start_utc</span> <span class="o">=</span> <span class="n">construct_utc_from_metadata</span><span class="p">(</span><span class="n">dstr</span><span class="p">,</span> <span class="n">t0</span><span class="p">)</span>
    <span class="c1"># Construct GPS starting time from data</span>
    <span class="n">end_utc</span> <span class="o">=</span> <span class="n">construct_utc_from_metadata</span><span class="p">(</span><span class="n">dstr</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span>
    <span class="c1"># Represent the range of times in the semi-open interval</span>
    <span class="k">return</span> <span class="n">segment</span><span class="p">(</span><span class="n">start_utc</span><span class="p">,</span><span class="n">end_utc</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="construct-utc-from-metadata">
<span id="id2"></span><h2>construct_utc_from_metadata<a class="headerlink" href="#construct-utc-from-metadata" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">construct_utc_from_metadata</span><span class="p">(</span><span class="n">datestr</span><span class="p">,</span> <span class="n">t0str</span><span class="p">):</span>
    <span class="n">instr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%d</span><span class="s2">-</span><span class="si">%d</span><span class="s2">-</span><span class="si">%02d</span><span class="s2">T&quot;</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">datestr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)))</span>
    <span class="n">instr</span> <span class="o">+=</span> <span class="n">t0str</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">Time</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;isot&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s1">&#39;utc&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">gps</span>
</pre></div>
</div>
</div>
<div class="section" id="generate-timeseries">
<span id="id3"></span><h2>generate_timeseries<a class="headerlink" href="#generate-timeseries" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_timeseries</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">setname</span><span class="o">=</span><span class="s2">&quot;MagneticFields&quot;</span><span class="p">):</span>
    <span class="n">full_data</span> <span class="o">=</span> <span class="n">TimeSeriesList</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data_list</span><span class="p">):</span>
        <span class="n">hfile</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">data_list</span><span class="p">[</span><span class="n">seg</span><span class="p">],</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">full_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">retrieve_data_timeseries</span><span class="p">(</span><span class="n">hfile</span><span class="p">,</span> <span class="s2">&quot;MagneticFields&quot;</span><span class="p">))</span>
        <span class="n">hfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">full_data</span>
</pre></div>
</div>
</div>
<div class="section" id="retrieve-data-timeseries">
<span id="id4"></span><h2>retrieve_data_timeseries<a class="headerlink" href="#retrieve-data-timeseries" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">retrieve_data_timeseries</span><span class="p">(</span><span class="n">hfile</span><span class="p">,</span> <span class="n">setname</span><span class="p">):</span>
    <span class="n">dset</span> <span class="o">=</span> <span class="n">hfile</span><span class="p">[</span><span class="n">setname</span><span class="p">]</span>
    <span class="n">sample_rate</span> <span class="o">=</span> <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;SamplingRate(Hz)&quot;</span><span class="p">]</span>
    <span class="n">gps_epoch</span> <span class="o">=</span> <span class="n">construct_utc_from_metadata</span><span class="p">(</span><span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;Date&quot;</span><span class="p">],</span> <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s2">&quot;t0&quot;</span><span class="p">])</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">retrieve_channel_data</span><span class="p">(</span><span class="n">hfile</span><span class="p">,</span> <span class="n">setname</span><span class="p">)</span>
    <span class="n">ts_data</span> <span class="o">=</span> <span class="n">TimeSeries</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">epoch</span><span class="o">=</span><span class="n">gps_epoch</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ts_data</span>
</pre></div>
</div>
</div>
<div class="section" id="retrieve-channel-data">
<span id="id5"></span><h2>retrieve_channel_data<a class="headerlink" href="#retrieve-channel-data" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">retrieve_channel_data</span><span class="p">(</span><span class="n">hfile</span><span class="p">,</span> <span class="n">setname</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">hfile</span><span class="p">[</span><span class="n">setname</span><span class="p">][:]</span>
</pre></div>
</div>
</div>
<div class="section" id="calculate-spectral-correlation">
<span id="id6"></span><h2>calculate_spectral_correlation<a class="headerlink" href="#calculate-spectral-correlation" title="Permalink to this headline">¶</a></h2>
<p>For our data, we apply a Tukey window whose flat bit corresponds to <code class="docutils literal"><span class="pre">window_fraction</span></code> (in percentage) of the segment length (in samples) used for PSD estimation (i.e. <code class="docutils literal"><span class="pre">fft_window_len</span></code>). This can be done by using the <a class="reference external" href="http://software.ligo.org/docs/lalsuite/lal/_window_8c_source.html#l00597">CreateTukeyREAL8Window</a> module from the <code class="docutils literal"><span class="pre">lal</span></code> library.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calculate_spectral_correlation</span><span class="p">(</span><span class="n">fft_window_len</span><span class="p">,</span> <span class="n">wtype</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span> <span class="n">window_fraction</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">wtype</span> <span class="o">==</span> <span class="s1">&#39;hann&#39;</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">lal</span><span class="o">.</span><span class="n">CreateHannREAL8Window</span><span class="p">(</span><span class="n">fft_window_len</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">wtype</span> <span class="o">==</span> <span class="s1">&#39;tukey&#39;</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">lal</span><span class="o">.</span><span class="n">CreateTukeyREAL8Window</span><span class="p">(</span><span class="n">fft_window_len</span><span class="p">,</span> <span class="n">window_fraction</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t handle window type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">wtype</span><span class="p">)</span>
</pre></div>
</div>
<p>Once the window is built, a new frequency plan is created which will help performing a <a class="reference external" href="http://fourier.eng.hmc.edu/e101/lectures/fourier_transform_d/node1.html">forward transform</a> on the data. This is done with the <a class="reference external" href="http://software.ligo.org/docs/lalsuite/lal/group___real_f_f_t__h.html#gac4413752db2d19cbe48742e922670af4">CreateForwardREAL8FFTPlan</a> module which takes as argument the total number of points in the real data and the measurement level for plan creation (here 1 stands for measuring the best plan).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fft_plan</span> <span class="o">=</span> <span class="n">lal</span><span class="o">.</span><span class="n">CreateForwardREAL8FFTPlan</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>We can finally compute and return the two-point spectral correlation function for the whitened frequency series (<code class="docutils literal"><span class="pre">fft_plan</span></code>) from the window applied to the original time series using the <a class="reference external" href="http://software.ligo.org/docs/lalsuite/lal/group___time_freq_f_f_t__h.html#ga2bd5c4258eff57cc80103d2ed489e076">REAL8WindowTwoPointSpectralCorrelation</a> module.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">window</span><span class="p">,</span> <span class="n">lal</span><span class="o">.</span><span class="n">REAL8WindowTwoPointSpectralCorrelation</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">fft_plan</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="create-filter-bank">
<span id="id7"></span><h2>create_filter_bank<a class="headerlink" href="#create-filter-bank" title="Permalink to this headline">¶</a></h2>
<p>The construction of a filter bank is fairly simple. For each channel, a frequency domain channel filter function will be created using the [[<a class="reference external" href="http://software.ligo.org/docs/lalsuite/lalburst/group___e_p_search__h.html#ga899990cbd45111ba907772650c265ec9][=CreateExcessPowerFilter=">http://software.ligo.org/docs/lalsuite/lalburst/group___e_p_search__h.html#ga899990cbd45111ba907772650c265ec9][=CreateExcessPowerFilter=</a>]] module from the =lalburst= package. Each channel filter is divided by the square root of the PSD frequency series prior to normalization, which has the effect of de-emphasizing frequency bins with high noise content, and is called &#8220;over whitening&#8221;. The data and metadata are finally stored in the =filter_fseries= and =filter_bank= arrays respectively. Finally, we store on a final array, called =np_filters= the all time-series generated from each filter so that we can plot them afterwards.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">create_filter_bank</span><span class="p">(</span><span class="n">delta_f</span><span class="p">,</span> <span class="n">flow</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">nchan</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">):</span>
    <span class="n">lal_psd</span> <span class="o">=</span> <span class="n">psd</span><span class="o">.</span><span class="n">lal</span><span class="p">()</span>
    <span class="n">lal_filters</span><span class="p">,</span> <span class="n">np_filters</span> <span class="o">=</span> <span class="p">[],[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchan</span><span class="p">):</span>
        <span class="n">lal_filter</span> <span class="o">=</span> <span class="n">lalburst</span><span class="o">.</span><span class="n">CreateExcessPowerFilter</span><span class="p">(</span><span class="n">flow</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="n">band</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">lal_psd</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">)</span>
        <span class="n">np_filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Spectrum</span><span class="o">.</span><span class="n">from_lal</span><span class="p">(</span><span class="n">lal_filter</span><span class="p">))</span>
        <span class="n">lal_filters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lal_filter</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">filter_fseries</span><span class="p">,</span> <span class="n">lal_filters</span><span class="p">,</span> <span class="n">np_filters</span>
</pre></div>
</div>
</div>
<div class="section" id="compute-filter-ips-self">
<span id="id8"></span><h2>compute_filter_ips_self<a class="headerlink" href="#compute-filter-ips-self" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_filter_ips_self</span><span class="p">(</span><span class="n">lal_filters</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a set of inner products of input filters with themselves. If psd</span>
<span class="sd">    argument is given, the unwhitened filter inner products will be returned.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lalburst</span><span class="o">.</span><span class="n">ExcessPowerFilterInnerProduct</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">lal_filters</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="compute-filter-ips-adjacent">
<span id="id9"></span><h2>compute_filter_ips_adjacent<a class="headerlink" href="#compute-filter-ips-adjacent" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_filter_ips_adjacent</span><span class="p">(</span><span class="n">lal_filters</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a set of filter inner products between input adjacent filters.</span>
<span class="sd">    If psd argument is given, the unwhitened filter inner products will be</span>
<span class="sd">    returned. The returned array index is the inner product between the</span>
<span class="sd">    lal_filter of the same index, and its (array) adjacent filter --- assumed</span>
<span class="sd">    to be the frequency adjacent filter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lalburst</span><span class="o">.</span><span class="n">ExcessPowerFilterInnerProduct</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span> <span class="k">for</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lal_filters</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lal_filters</span><span class="p">[</span><span class="mi">1</span><span class="p">:])])</span>
</pre></div>
</div>
</div>
<div class="section" id="compute-channel-renormalization">
<span id="compute-channel-renomalization"></span><h2>Compute channel renormalization<a class="headerlink" href="#compute-channel-renormalization" title="Permalink to this headline">¶</a></h2>
<p>Compute the renormalization for the base filters up to a given bandwidth.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compute_channel_renomalization</span><span class="p">(</span><span class="n">nc_sum</span><span class="p">,</span> <span class="n">lal_filters</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">nchans</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">mu_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">nc_sum</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lalburst</span><span class="o">.</span><span class="n">ExcessPowerFilterInnerProduct</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">lal_filters</span><span class="p">])</span>
    <span class="c1"># Uncomment to get all possible frequency renormalizations</span>
    <span class="c1">#for n in xrange(nc_sum, nchans): # channel position index</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">nc_sum</span><span class="p">,</span> <span class="n">nchans</span><span class="p">,</span> <span class="n">nc_sum</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1"># channel position index</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nc_sum</span><span class="p">):</span> <span class="c1"># channel sum index</span>
            <span class="c1"># FIXME: We&#39;ve precomputed this, so use it instead</span>
            <span class="n">mu_sq</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">lalburst</span><span class="o">.</span><span class="n">ExcessPowerFilterInnerProduct</span><span class="p">(</span><span class="n">lal_filters</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="p">],</span> <span class="n">lal_filters</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">],</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="c1">#print mu_sq[nc_sum::nc_sum+1]</span>
    <span class="k">return</span> <span class="n">mu_sq</span>
</pre></div>
</div>
</div>
<div class="section" id="measure-hrss">
<span id="id10"></span><h2>measure_hrss<a class="headerlink" href="#measure-hrss" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">measure_hrss</span><span class="p">(</span><span class="n">z_j_b</span><span class="p">,</span> <span class="n">uw_ss_ii</span><span class="p">,</span> <span class="n">uw_ss_ij</span><span class="p">,</span> <span class="n">w_ss_ij</span><span class="p">,</span> <span class="n">delta_f</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">filter_len</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Approximation of unwhitened sum of squares signal energy in a given EP tile.</span>
<span class="sd">    See T1200125 for equation number reference.</span>
<span class="sd">    z_j_b      - time frequency map block which the constructed tile covers</span>
<span class="sd">    uw_ss_ii   - unwhitened filter inner products</span>
<span class="sd">    uw_ss_ij   - unwhitened adjacent filter inner products</span>
<span class="sd">    w_ss_ij    - whitened adjacent filter inner products</span>
<span class="sd">    delta_f    - frequency binning of EP filters</span>
<span class="sd">    delta_t    - native time resolution of the time frequency map</span>
<span class="sd">    filter_len - number of samples in a fitler</span>
<span class="sd">    dof        - degrees of freedom in the tile (twice the time-frequency area)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s_j_b_avg</span> <span class="o">=</span> <span class="n">uw_ss_ii</span> <span class="o">*</span> <span class="n">delta_f</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="c1"># unwhitened sum of squares of wide virtual filter</span>
    <span class="n">s_j_nb_avg</span> <span class="o">=</span> <span class="n">uw_ss_ii</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">uw_ss_ij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">s_j_nb_avg</span> <span class="o">*=</span> <span class="n">delta_f</span>
    <span class="n">s_j_nb_denom</span> <span class="o">=</span> <span class="n">s_j_b_avg</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">filter_len</span> <span class="o">*</span> \
        <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_j_b_avg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">s_j_b_avg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">*</span> <span class="n">w_ss_ij</span><span class="p">)</span>
    <span class="c1"># eqn. 62</span>
    <span class="n">uw_ups_ratio</span> <span class="o">=</span> <span class="n">s_j_nb_avg</span> <span class="o">/</span> <span class="n">s_j_nb_denom</span>
    <span class="c1"># eqn. 63 -- approximation of unwhitened signal energy time series</span>
    <span class="c1"># FIXME: The sum in this equation is over nothing, but indexed by frequency</span>
    <span class="c1"># I&#39;ll make that assumption here too.</span>
    <span class="n">s_j_nb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z_j_b</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_j_b_avg</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">s_j_nb</span> <span class="o">*=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uw_ups_ratio</span> <span class="o">/</span> <span class="n">filter_len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># eqn. 64 -- approximate unwhitened signal energy minus noise contribution</span>
    <span class="c1"># FIXME: correct axis of summation?</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">s_j_nb</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">delta_t</span> <span class="o">-</span> <span class="n">s_j_nb_avg</span> <span class="o">*</span> <span class="n">dof</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="uw-sum-sq">
<span id="id11"></span><h2>uw_sum_sq<a class="headerlink" href="#uw-sum-sq" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># &lt; s^2_j(f_1, b) &gt; = 1 / 2 / N * \delta_t EPIP{\Theta, \Theta; P}</span>
<span class="k">def</span> <span class="nf">uw_sum_sq</span><span class="p">(</span><span class="n">filter1</span><span class="p">,</span> <span class="n">filter2</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">psd</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lalburst</span><span class="o">.</span><span class="n">ExcessPowerFilterInnerProduct</span><span class="p">(</span><span class="n">filter1</span><span class="p">,</span> <span class="n">filter2</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="measure-hrss-slowly">
<span id="id12"></span><h2>measure_hrss_slowly<a class="headerlink" href="#measure-hrss-slowly" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">measure_hrss_slowly</span><span class="p">(</span><span class="n">z_j_b</span><span class="p">,</span> <span class="n">lal_filters</span><span class="p">,</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">psd</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
   <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">   Approximation of unwhitened sum of squares signal energy in a given EP tile.</span>
<span class="sd">   See T1200125 for equation number reference. NOTE: This function is deprecated</span>
<span class="sd">   in favor of measure_hrss, since it requires recomputation of many inner products,</span>
<span class="sd">   making it particularly slow.</span>
<span class="sd">   &quot;&quot;&quot;</span>
   <span class="c1"># FIXME: Make sure you sum in time correctly</span>
   <span class="c1"># Number of finest bands in given tile</span>
   <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">z_j_b</span><span class="p">)</span>
   <span class="c1"># eqn. 56 -- unwhitened mean square of filter with itself</span>
   <span class="n">uw_ss_ii</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uw_sum_sq</span><span class="p">(</span><span class="n">lal_filters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lal_filters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">)])</span>
   <span class="n">s_j_b_avg</span> <span class="o">=</span> <span class="n">uw_ss_ii</span> <span class="o">*</span> <span class="n">lal_filters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">deltaF</span> <span class="o">/</span> <span class="mi">2</span>
   <span class="c1"># eqn. 57 -- unwhitened mean square of filter with adjacent filter</span>
   <span class="n">uw_ss_ij</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uw_sum_sq</span><span class="p">(</span><span class="n">lal_filters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lal_filters</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="n">psd</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
   <span class="c1"># unwhitened sum of squares of wide virtual filter</span>
   <span class="n">s_j_nb_avg</span> <span class="o">=</span> <span class="n">uw_ss_ii</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">uw_ss_ij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
   <span class="n">s_j_nb_avg</span> <span class="o">*=</span> <span class="n">lal_filters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">deltaF</span>

   <span class="c1"># eqn. 61</span>
   <span class="n">w_ss_ij</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uw_sum_sq</span><span class="p">(</span><span class="n">lal_filters</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lal_filters</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">spec_corr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="o">-</span><span class="mi">1</span><span class="p">)])</span>
   <span class="n">s_j_nb_denom</span> <span class="o">=</span> <span class="n">s_j_b_avg</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">lal_filters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> \
       <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_j_b_avg</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">s_j_b_avg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">*</span> <span class="n">w_ss_ij</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

   <span class="c1"># eqn. 62</span>
   <span class="n">uw_ups_ratio</span> <span class="o">=</span> <span class="n">s_j_nb_avg</span> <span class="o">/</span> <span class="n">s_j_nb_denom</span>

   <span class="c1"># eqn. 63 -- approximation of unwhitened signal energy time series</span>
   <span class="c1"># FIXME: The sum in this equation is over nothing, but indexed by frequency</span>
   <span class="c1"># I&#39;ll make that assumption here too.</span>
   <span class="n">s_j_nb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">z_j_b</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">s_j_b_avg</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
   <span class="n">s_j_nb</span> <span class="o">*=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">uw_ups_ratio</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">lal_filters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
   <span class="c1"># eqn. 64 -- approximate unwhitened signal energy minus noise contribution</span>
   <span class="c1"># FIXME: correct axis of summation?</span>
   <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">s_j_nb</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">delta_t</span> <span class="o">-</span> <span class="n">s_j_nb_avg</span> <span class="o">*</span> <span class="n">dof</span> <span class="o">*</span> <span class="n">delta_t</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="measure-hrss-poorly">
<span id="id13"></span><h2>measure_hrss_poorly<a class="headerlink" href="#measure-hrss-poorly" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">measure_hrss_poorly</span><span class="p">(</span><span class="n">tile_energy</span><span class="p">,</span> <span class="n">sub_psd</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tile_energy</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">sub_psd</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="trigger-list-from-map">
<span id="id14"></span><h2>trigger_list_from_map<a class="headerlink" href="#trigger-list-from-map" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">trigger_list_from_map</span><span class="p">(</span><span class="n">tfmap</span><span class="p">,</span> <span class="n">event_list</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">start_time</span><span class="p">,</span> <span class="n">start_freq</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">band</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">psd</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="c1"># FIXME: If we don&#39;t convert this the calculation takes forever --- but we should convert it once and handle deltaF better later</span>
    <span class="k">if</span> <span class="n">psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">npy_psd</span> <span class="o">=</span> <span class="n">psd</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span>

    <span class="n">start_time</span> <span class="o">=</span> <span class="n">LIGOTimeGPS</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">start_time</span><span class="p">))</span>
    <span class="n">ndof</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">duration</span> <span class="o">*</span> <span class="n">band</span>

    <span class="n">spanf</span><span class="p">,</span> <span class="n">spant</span> <span class="o">=</span> <span class="n">tfmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">df</span><span class="p">,</span> <span class="n">tfmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="nb">print</span> <span class="s2">&quot;Processing </span><span class="si">%.2f</span><span class="s2">x</span><span class="si">%.2f</span><span class="s2"> time-frequency map.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">spant</span><span class="p">,</span> <span class="n">spanf</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tfmap</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)):</span>
        <span class="n">event</span> <span class="o">=</span> <span class="n">event_list</span><span class="o">.</span><span class="n">RowType</span><span class="p">()</span>

        <span class="c1"># The points are summed forward in time and thus a `summed point&#39; is the</span>
        <span class="c1"># sum of the previous N points. If this point is above threshold, it</span>
        <span class="c1"># corresponds to a tile which spans the previous N points. However, th</span>
        <span class="c1"># 0th point (due to the convolution specifier &#39;valid&#39;) is actually</span>
        <span class="c1"># already a duration from the start time. All of this means, the +</span>
        <span class="c1"># duration and the - duration cancels, and the tile &#39;start&#39; is, by</span>
        <span class="c1"># definition, the start of the time frequency map if j = 0</span>
        <span class="c1"># FIXME: I think this needs a + dt/2 to center the tile properly</span>
        <span class="n">event</span><span class="o">.</span><span class="n">set_start</span><span class="p">(</span><span class="n">start_time</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">))</span>
        <span class="n">event</span><span class="o">.</span><span class="n">set_stop</span><span class="p">(</span><span class="n">start_time</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">j</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">duration</span><span class="p">)</span>
        <span class="n">event</span><span class="o">.</span><span class="n">set_peak</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">get_start</span><span class="p">()</span> <span class="o">+</span> <span class="n">duration</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">event</span><span class="o">.</span><span class="n">central_freq</span> <span class="o">=</span> <span class="n">start_freq</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">df</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">band</span>

        <span class="n">event</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="n">event</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">=</span> <span class="n">band</span>
        <span class="n">event</span><span class="o">.</span><span class="n">chisq_dof</span> <span class="o">=</span> <span class="n">ndof</span>

        <span class="n">event</span><span class="o">.</span><span class="n">snr</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tfmap</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">event</span><span class="o">.</span><span class="n">chisq_dof</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># FIXME: Magic number 0.62 should be determine empircally</span>
        <span class="n">event</span><span class="o">.</span><span class="n">confidence</span> <span class="o">=</span> <span class="o">-</span><span class="n">lal</span><span class="o">.</span><span class="n">LogChisqCCDF</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">snr</span> <span class="o">*</span> <span class="mf">0.62</span><span class="p">,</span> <span class="n">event</span><span class="o">.</span><span class="n">chisq_dof</span> <span class="o">*</span> <span class="mf">0.62</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># NOTE: I think the pycbc PSDs always start at 0 Hz --- check</span>
            <span class="n">psd_idx_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">event</span><span class="o">.</span><span class="n">central_freq</span> <span class="o">-</span> <span class="n">event</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">psd</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>
            <span class="n">psd_idx_max</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">event</span><span class="o">.</span><span class="n">central_freq</span> <span class="o">+</span> <span class="n">event</span><span class="o">.</span><span class="n">bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">psd</span><span class="o">.</span><span class="n">delta_f</span><span class="p">)</span>

            <span class="c1"># FIXME: heuristically this works better with E - D -- it&#39;s all</span>
            <span class="c1"># going away with the better h_rss calculation soon anyway</span>
            <span class="n">event</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">measure_hrss_poorly</span><span class="p">(</span><span class="n">tfmap</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">event</span><span class="o">.</span><span class="n">chisq_dof</span><span class="p">,</span> <span class="n">npy_psd</span><span class="p">[</span><span class="n">psd_idx_min</span><span class="p">:</span><span class="n">psd_idx_max</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">event</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">event</span><span class="o">.</span><span class="n">process_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">event</span><span class="o">.</span><span class="n">event_id</span> <span class="o">=</span> <span class="n">event_list</span><span class="o">.</span><span class="n">get_next_id</span><span class="p">()</span>
        <span class="n">event_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="determine-output-segment">
<span id="id15"></span><h2>determine_output_segment<a class="headerlink" href="#determine-output-segment" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">determine_output_segment</span><span class="p">(</span><span class="n">inseg</span><span class="p">,</span> <span class="n">dt_stride</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">window_fraction</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an input data stretch segment inseg, a data block stride dt_stride, the data sample rate, and an optional window_fraction, return the amount of data that can be processed without corruption effects from the window.</span>

<span class="sd">    If window_fration is set to 0 (default), assume no windowing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Amount to overlap successive blocks so as not to lose data</span>
    <span class="n">window_overlap_samples</span> <span class="o">=</span> <span class="n">window_fraction</span> <span class="o">*</span> <span class="n">sample_rate</span>
    <span class="n">outseg</span> <span class="o">=</span> <span class="n">inseg</span><span class="o">.</span><span class="n">contract</span><span class="p">(</span><span class="n">window_fraction</span> <span class="o">*</span> <span class="n">dt_stride</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># With a given dt_stride, we cannot process the remainder of this data</span>
    <span class="n">remainder</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">outseg</span><span class="p">),</span> <span class="n">dt_stride</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">window_fraction</span><span class="p">))</span>
    <span class="c1"># ...so make an accounting of it</span>
    <span class="n">outseg</span> <span class="o">=</span> <span class="n">segment</span><span class="p">(</span><span class="n">outseg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">outseg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">outseg</span>
</pre></div>
</div>
</div>
<div class="section" id="make-tiles">
<span id="id16"></span><h2>make_tiles<a class="headerlink" href="#make-tiles" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_tiles</span><span class="p">(</span><span class="n">tf_map</span><span class="p">,</span> <span class="n">nc_sum</span><span class="p">,</span> <span class="n">mu_sq</span><span class="p">):</span>
    <span class="n">tiles</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">tf_map</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">sum_filter</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nc_sum</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Here&#39;s the deal: we&#39;re going to keep only the valid output and</span>
    <span class="c1"># it&#39;s *always* going to exist in the lowest available indices</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">tf_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="c1"># Sum and drop correlate tiles</span>
        <span class="c1"># FIXME: don&#39;t drop correlated tiles</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">tf_map</span><span class="p">[:,</span><span class="n">t</span><span class="p">],</span> <span class="n">sum_filter</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)[::</span><span class="n">nc_sum</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#output = fftconvolve(tf_map[:,t], sum_filter, &#39;valid&#39;)[::nc_sum+1]</span>
        <span class="n">tiles</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">),</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tiles</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)]</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">mu_sq</span><span class="p">[</span><span class="n">nc_sum</span><span class="p">::</span><span class="n">nc_sum</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="make-indp-tiles">
<span id="id17"></span><h2>make_indp_tiles<a class="headerlink" href="#make-indp-tiles" title="Permalink to this headline">¶</a></h2>
<p>In this function, we create a time frequency map with resolution similar than =tf_map= but rescale by a factor of =nc_sum= + 1. All tiles will be independent up to overlap from the original tiling. The =mu_sq= is applied to the resulting addition to normalize the outputs to be zero-mean unit-variance Gaussian variables (if the input is Gaussian).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_indp_tiles</span><span class="p">(</span><span class="n">tf_map</span><span class="p">,</span> <span class="n">nc_sum</span><span class="p">,</span> <span class="n">mu_sq</span><span class="p">):</span>
    <span class="n">tiles</span> <span class="o">=</span> <span class="n">tf_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># Here&#39;s the deal: we&#39;re going to keep only the valid output and</span>
    <span class="c1"># it&#39;s *always* going to exist in the lowest available indices</span>
    <span class="n">stride</span> <span class="o">=</span> <span class="n">nc_sum</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="n">tiles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">stride</span><span class="p">):</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">tiles</span><span class="p">[</span><span class="n">stride</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="n">stride</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">tiles</span><span class="p">[</span><span class="n">stride</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">tiles</span><span class="p">[</span><span class="n">nc_sum</span><span class="p">::</span><span class="n">nc_sum</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">mu_sq</span><span class="p">[</span><span class="n">nc_sum</span><span class="p">::</span><span class="n">nc_sum</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="make-filename">
<span id="id18"></span><h2>make_filename<a class="headerlink" href="#make-filename" title="Permalink to this headline">¶</a></h2>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_filename</span><span class="p">(</span><span class="n">ifo</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;excesspower&quot;</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="s2">&quot;xml.gz&quot;</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ifo</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">ifostr</span> <span class="o">=</span> <span class="n">ifo</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ifostr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ifo</span><span class="p">)</span>
    <span class="n">st_rnd</span><span class="p">,</span> <span class="n">end_rnd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">seg</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">dur</span> <span class="o">=</span> <span class="n">end_rnd</span> <span class="o">-</span> <span class="n">st_rnd</span>
    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">-</span><span class="si">%d</span><span class="s2">-</span><span class="si">%d</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ifostr</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">st_rnd</span><span class="p">,</span> <span class="n">dur</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="sphinx-toc sphinxlocaltoc">
    <h3><a href="index.html">Page contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Submodules</a><ul>
<li><a class="reference internal" href="#file-to-segment">file_to_segment</a></li>
<li><a class="reference internal" href="#construct-utc-from-metadata">construct_utc_from_metadata</a></li>
<li><a class="reference internal" href="#generate-timeseries">generate_timeseries</a></li>
<li><a class="reference internal" href="#retrieve-data-timeseries">retrieve_data_timeseries</a></li>
<li><a class="reference internal" href="#retrieve-channel-data">retrieve_channel_data</a></li>
<li><a class="reference internal" href="#calculate-spectral-correlation">calculate_spectral_correlation</a></li>
<li><a class="reference internal" href="#create-filter-bank">create_filter_bank</a></li>
<li><a class="reference internal" href="#compute-filter-ips-self">compute_filter_ips_self</a></li>
<li><a class="reference internal" href="#compute-filter-ips-adjacent">compute_filter_ips_adjacent</a></li>
<li><a class="reference internal" href="#compute-channel-renormalization">Compute channel renormalization</a></li>
<li><a class="reference internal" href="#measure-hrss">measure_hrss</a></li>
<li><a class="reference internal" href="#uw-sum-sq">uw_sum_sq</a></li>
<li><a class="reference internal" href="#measure-hrss-slowly">measure_hrss_slowly</a></li>
<li><a class="reference internal" href="#measure-hrss-poorly">measure_hrss_poorly</a></li>
<li><a class="reference internal" href="#trigger-list-from-map">trigger_list_from_map</a></li>
<li><a class="reference internal" href="#determine-output-segment">determine_output_segment</a></li>
<li><a class="reference internal" href="#make-tiles">make_tiles</a></li>
<li><a class="reference internal" href="#make-indp-tiles">make_indp_tiles</a></li>
<li><a class="reference internal" href="#make-filename">make_filename</a></li>
</ul>
</li>
</ul>

  </div>
  <div class="sphinxprev">
    <h4>Previous page</h4>
    <p class="topless"><a href="excess_power.html"
                          title="Previous page">&larr; Description of the code</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/excess_power_submodules.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 «
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 »
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="excess_power.html" title="Description of the code"
             >previous</a> &nbsp; &nbsp;</li>
    <li><a href="index.html">gdas 0.3.0 documentation</a> &#187;</li>
 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Vincent Dumont.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.5.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>